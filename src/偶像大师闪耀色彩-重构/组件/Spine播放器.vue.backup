<template>
  <div ref="spineContainer" class="spine-player-wrapper">
    <canvas ref="canvasElement" class="spine-canvas"></canvas>
  </div>
</template>

<script setup lang="ts">
import * as PIXI from 'pixi.js';
import { onMounted, onUnmounted, ref, watch } from 'vue';
import { useSpineAnimationManager } from '../å·¥å…·/spine-animation-manager';

// Props
const props = defineProps<{
  idolId: string; // æ”¹ä¸º idolId ä»¥åŒ¹é…ä¸»é¡µä¼ é€’çš„ prop å
}>();

// Refs
const spineContainer = ref<HTMLDivElement | null>(null);
const canvasElement = ref<HTMLCanvasElement | null>(null);

// çŠ¶æ€
let app: PIXI.Application | null = null;

// åŠ¨ç”»ç®¡ç†å™¨
const animationManager = useSpineAnimationManager();

// ç›‘å¬ idolId å˜åŒ–
watch(
  () => props.idolId,
  async newId => {
    if (newId) {
      await loadSpineAsset(newId);
    }
  },
);

// ç»„ä»¶æŒ‚è½½
onMounted(async () => {
  console.log('ğŸ¬ Spine æ’­æ”¾å™¨ç»„ä»¶æŒ‚è½½');

  // ç­‰å¾… v8-spine37.js åŠ è½½
  await waitForSpine37();

  // åˆå§‹åŒ– PixiJS åº”ç”¨
  await initPixiApp();

  // åŠ è½½åˆå§‹ Spine èµ„æº
  if (props.idolId) {
    await loadSpineAsset(props.idolId);
  }
});

// ç»„ä»¶å¸è½½
onUnmounted(() => {
  console.log('ğŸ‘‹ Spine æ’­æ”¾å™¨ç»„ä»¶å¸è½½');
  if (app) {
    app.destroy(true, { children: true, texture: true });
  }
});

/**
 * ç­‰å¾… v8-spine37.js åŠ è½½å®Œæˆ
 */
async function waitForSpine37(): Promise<void> {
  return new Promise((resolve, reject) => {
    const checkInterval = setInterval(() => {
      if ((window as any).PIXI?.Spine37) {
        clearInterval(checkInterval);
        console.log('âœ… PIXI.Spine37 å·²åŠ è½½');
        resolve();
      }
    }, 100);

    // è¶…æ—¶å¤„ç†ï¼ˆ5ç§’ï¼Œå› ä¸ºè„šæœ¬å·²ç›´æ¥æ‰“åŒ…ï¼‰
    setTimeout(() => {
      clearInterval(checkInterval);
      if (!(window as any).PIXI?.Spine37) {
        console.error('âŒ PIXI.Spine37 åŠ è½½è¶…æ—¶ï¼ˆ5ç§’ï¼‰');
        console.error('window.PIXI:', (window as any).PIXI);
        console.error('è¯·æ£€æŸ¥ PixiJS æ˜¯å¦æ­£ç¡®åŠ è½½');
        reject(new Error('PIXI.Spine37 åŠ è½½è¶…æ—¶'));
      }
    }, 5000);
  });
}

/**
 * åˆå§‹åŒ– PixiJS åº”ç”¨
 */
async function initPixiApp() {
  if (!canvasElement.value) {
    console.error('âŒ Canvas å…ƒç´ æœªæ‰¾åˆ°');
    return;
  }

  console.log('ğŸ“¦ åˆå§‹åŒ– PixiJS åº”ç”¨...');

  app = new PIXI.Application();
  await app.init({
    canvas: canvasElement.value,
    width: canvasElement.value.clientWidth || 800,
    height: canvasElement.value.clientHeight || 600,
    backgroundColor: 0x000000,
    backgroundAlpha: 0, // é€æ˜èƒŒæ™¯
  });

  // æ£€æŸ¥å¹¶æ³¨å†Œ SpinePipe
  const renderer = app.renderer as any;
  console.log('ğŸ“¦ Renderer pipes:', Object.keys(renderer.renderPipes || {}));

  if (!renderer.renderPipes?.spine) {
    console.warn('âš ï¸ SpinePipe æœªè‡ªåŠ¨æ³¨å†Œï¼Œå°è¯•æ‰‹åŠ¨æ³¨å†Œ...');

    // ä» PIXI.Spine37 è·å– SpinePipe
    const Spine37 = (window as any).PIXI.Spine37;
    if (Spine37 && Spine37.SpinePipe) {
      try {
        // æ‰‹åŠ¨å®ä¾‹åŒ– SpinePipe
        const spinePipe = new Spine37.SpinePipe(renderer);
        renderer.renderPipes.spine = spinePipe;
        console.log('âœ… SpinePipe æ‰‹åŠ¨æ³¨å†ŒæˆåŠŸ');
      } catch (error) {
        console.error('âŒ SpinePipe æ‰‹åŠ¨æ³¨å†Œå¤±è´¥:', error);
      }
    } else {
      console.error('âŒ PIXI.Spine37.SpinePipe ä¸å­˜åœ¨');
    }
  } else {
    console.log('âœ… SpinePipe å·²æ³¨å†Œ');
  }

  // è®© PixiJS å’Œ Spine å®Œå…¨è‡ªåŠ¨ç®¡ç†æ›´æ–°å’Œæ¸²æŸ“
  let frameCount = 0;

  app.ticker.add(() => {
    // æ¯ 60 å¸§æ‰“å°ä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
    if (++frameCount % 60 === 0 && app) {
      console.log('ğŸ¬ æ¸²æŸ“å¸§:', frameCount, 'Stage children:', app.stage.children.length);
    }
  });

  console.log('âœ… PixiJS åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
}

/**
 * åŠ è½½ Spine èµ„æºï¼ˆæ‰‹åŠ¨åŠ è½½ï¼Œå‚è€ƒ ShinyColorsDB-SpineViewer åŸé¡¹ç›®ï¼‰
 */
async function loadSpineAsset(idolId: string) {
  if (!app) {
    console.error('âŒ PixiJS åº”ç”¨æœªåˆå§‹åŒ–');
    return;
  }

  try {
    console.log(`ğŸ¬ å¼€å§‹åŠ è½½ Spine èµ„æº: ${idolId}`);

    // è§£æ idolId
    const [characterName, costumeName] = idolId.split('_');
    // ä½¿ç”¨ jsDelivr CDN + æœ€æ–° commit hash (0570c07 - æ¢å¤åŸå§‹ Spine 3.x èµ„æº)
    const baseUrl = `https://cdn.jsdelivr.net/gh/2426269/shinycolors-assets-cdn@0570c07/spine/${characterName}/${costumeName}`;

    const skelUrl = `${baseUrl}/${costumeName}.json`;
    const atlasUrl = `${baseUrl}/${costumeName}.atlas`;

    console.log('ğŸ“¦ Skeleton URL:', skelUrl);
    console.log('ğŸ“¦ Atlas URL:', atlasUrl);

    // æ‰‹åŠ¨åŠ è½½ skeleton JSON å¹¶æ³¨å†Œåˆ° Assets ç³»ç»Ÿ
    const skeletonResponse = await fetch(skelUrl);
    const skeletonJson = await skeletonResponse.json();

    // ä½¿ç”¨ Assets.add() + cache.set() çš„ç»„åˆæ–¹å¼
    PIXI.Assets.add({ alias: `skel_${idolId}`, src: `skel_${idolId}` });
    PIXI.Assets.cache.set(`skel_${idolId}`, skeletonJson);
    console.log('âœ… Skeleton JSON åŠ è½½å®Œæˆ');

    // æ‰‹åŠ¨åŠ è½½ atlas æ–‡æœ¬å¹¶æ³¨å†Œåˆ° Assets ç³»ç»Ÿ
    const atlasResponse = await fetch(atlasUrl);
    const atlasText = await atlasResponse.text();
    console.log('âœ… Atlas æ–‡æœ¬åŠ è½½å®Œæˆ');

    // åˆ›å»º TextureAtlasï¼ˆå‚è€ƒåŸé¡¹ç›® main.js createDropSpine å‡½æ•°ï¼‰
    const Spine37 = (window as any).PIXI.Spine37;
    const textureAtlas = new Spine37.TextureAtlas(atlasText);

    // ä½¿ç”¨ Assets.add() + cache.set() çš„ç»„åˆæ–¹å¼
    PIXI.Assets.add({ alias: `atlas_${idolId}`, src: `atlas_${idolId}` });
    PIXI.Assets.cache.set(`atlas_${idolId}`, textureAtlas);
    console.log('âœ… TextureAtlas åˆ›å»ºå®Œæˆ');

    // åŠ è½½æ‰€æœ‰çº¹ç†é¡µ
    const textureLoadingPromises = [];
    for (const page of textureAtlas.pages) {
      console.log(`ğŸ“¦ åŠ è½½çº¹ç†: ${page.name}`);

      const textureUrl = `${baseUrl}/${page.name}`;
      const pixiPromise = PIXI.Assets.load({
        alias: page.name,
        src: textureUrl,
        data: {
          alphaMode: page.pma ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload',
        },
      }).then(rawtexture => {
        page.setTexture(Spine37.SpineTexture.from(rawtexture.source));
        console.log(`âœ… çº¹ç†å·²è®¾ç½®: ${page.name}`);
      });

      textureLoadingPromises.push(pixiPromise);
    }
    await Promise.all(textureLoadingPromises);
    console.log('âœ… æ‰€æœ‰çº¹ç†åŠ è½½å®Œæˆ');

    // è°ƒè¯•ï¼šæ£€æŸ¥ç¼“å­˜ä¸­çš„æ•°æ®
    const cachedSkel = PIXI.Assets.cache.get(`skel_${idolId}`);
    console.log('ğŸ” ç¼“å­˜æ£€æŸ¥ - Assets.cache.get() Skeleton:', cachedSkel ? 'âœ…' : 'âŒ', cachedSkel);
    console.log('ğŸ” ç¼“å­˜æ£€æŸ¥ - Skeleton.skeleton.spine:', cachedSkel?.skeleton?.spine);
    console.log(
      'ğŸ” ç¼“å­˜æ£€æŸ¥ - Skeleton.skins ç±»å‹:',
      Array.isArray(cachedSkel?.skins) ? 'Array (Spine 4.x)' : 'Object (Spine 3.x)',
    );

    // å…³é”®ï¼šæ£€æŸ¥ Assets.get() æ˜¯å¦èƒ½è·å–åˆ°æ•°æ®ï¼ˆSpine.from() å†…éƒ¨ä½¿ç”¨çš„æ˜¯è¿™ä¸ªï¼‰
    const assetsGetSkel = PIXI.Assets.get(`skel_${idolId}`);
    const assetsGetAtlas = PIXI.Assets.get(`atlas_${idolId}`);
    console.log('ğŸ” å…³é”®æ£€æŸ¥ - Assets.get() Skeleton:', assetsGetSkel ? 'âœ…' : 'âŒ');
    console.log('ğŸ” å…³é”®æ£€æŸ¥ - Assets.get() Atlas:', assetsGetAtlas ? 'âœ…' : 'âŒ');

    console.log('ğŸ”§ å°è¯•ä½¿ç”¨ Spine.from() åˆ›å»ºå®ä¾‹ï¼ˆå‚è€ƒé¡¹ç›®æ–¹å¼ï¼‰');

    // ä½¿ç”¨ Spine.from() - è¿™æ˜¯å‚è€ƒé¡¹ç›®ä½¿ç”¨çš„æ–¹å¼
    let spine;
    try {
      spine = Spine37.Spine.from({
        skeleton: `skel_${idolId}`,
        atlas: `atlas_${idolId}`,
      });
      console.log('âœ… Spine.from() åˆ›å»ºæˆåŠŸ');
    } catch (error) {
      console.error('âŒ Spine.from() å¤±è´¥ï¼Œå›é€€åˆ°æ‰‹åŠ¨åˆ›å»º:', error);

      // å›é€€ï¼šæ‰‹åŠ¨åˆ›å»º
      const attachmentLoader = new Spine37.AtlasAttachmentLoader(assetsGetAtlas);
      const parser = new Spine37.SkeletonJson(attachmentLoader);
      parser.scale = 1;
      const skeletonData = parser.readSkeletonData(assetsGetSkel);
      spine = new Spine37.Spine({ skeletonData });
      console.log('âœ… æ‰‹åŠ¨åˆ›å»º Spine æˆåŠŸï¼ˆå›é€€æ–¹å¼ï¼‰');
    }

    console.log('âœ… Spine å®ä¾‹åˆ›å»ºæˆåŠŸ');
    console.log('ğŸ“¦ Spine æ¸²æŸ“æ–¹æ³•æ£€æŸ¥:', {
      hasCollectRenderables: typeof spine.collectRenderables === 'function',
      hasCollectRenderablesSimple: typeof spine.collectRenderablesSimple === 'function',
      hasUpdate: typeof spine.update === 'function',
    });

    // å…³é”®ä¿®å¤ï¼šä» Container å¤åˆ¶ collectRenderablesï¼Œä½†ä¿®æ”¹ä»¥æ”¯æŒ Spine
    if (!spine.collectRenderables) {
      console.log('âš ï¸ Spine ç¼ºå°‘ collectRenderables æ–¹æ³•ï¼Œä» Container å¤åˆ¶...');

      const containerProto = (PIXI.Container as any).prototype;

      // ä» Container å¤åˆ¶æ–¹æ³•
      spine.collectRenderables = containerProto.collectRenderables.bind(spine);
      spine.collectRenderablesSimple = containerProto.collectRenderablesSimple.bind(spine);
      spine.collectRenderablesWithEffects = containerProto.collectRenderablesWithEffects.bind(spine);

      console.log('âœ… æ¸²æŸ“æ–¹æ³•å·²ä» Container å¤åˆ¶');
    }

    console.log('ğŸ“¦ Spine æœ€ç»ˆæ¸²æŸ“æ–¹æ³•çŠ¶æ€:', {
      hasCollectRenderables: typeof spine.collectRenderables === 'function',
      hasCollectRenderablesSimple: typeof spine.collectRenderablesSimple === 'function',
      hasUpdate: typeof spine.update === 'function',
    });

    console.log('ğŸ“¦ Spine å±æ€§æ£€æŸ¥:', {
      batched: spine.batched,
      renderPipeId: spine.renderPipeId,
      spineAttachmentsDirty: spine.spineAttachmentsDirty,
      spineTexturesDirty: spine.spineTexturesDirty,
      uid: spine.uid,
    });

    // è®¾ç½®çš®è‚¤
    try {
      spine.skeleton.setSkinByName('normal');
    } catch (e) {
      spine.skeleton.setSkinByName('default');
    }

    // åˆå§‹åŒ– Spineï¼ˆå‚è€ƒ ShinyColorsDB-SpineViewerï¼‰
    spine.skeleton.setToSetupPose();
    console.log('âœ… Spine åˆå§‹åŒ–å®Œæˆï¼ˆå»¶è¿Ÿè°ƒç”¨ _validateAndTransformAttachments åˆ°æ·»åŠ  stage ä¹‹åï¼‰');

    // è·å–åŠ¨ç”»åˆ—è¡¨
    const animations = spine.skeleton.data.animations.map((anim: any) => anim.name);
    console.log('ğŸ¬ å¯ç”¨åŠ¨ç”»åˆ—è¡¨:', animations);

    // æ’­æ”¾é»˜è®¤åŠ¨ç”»
    const defaultAnimation = 'wait';
    if (animations.includes(defaultAnimation)) {
      spine.state.setAnimation(0, defaultAnimation, true);
      console.log(`â–¶ï¸ æ’­æ”¾åŠ¨ç”»: ${defaultAnimation}`);
    } else if (animations.length > 0) {
      spine.state.setAnimation(0, animations[0], true);
      console.log(`â–¶ï¸ æ’­æ”¾åŠ¨ç”»: ${animations[0]}`);
    }

    // å†æ¬¡ update ä»¥åº”ç”¨åŠ¨ç”»
    spine.update(0);

    // å±…ä¸­æ˜¾ç¤º
    renderToStage(spine);

    // ç»‘å®šåˆ°åŠ¨ç”»ç®¡ç†å™¨
    animationManager.setSpine(spine);

    console.log('âœ… Spine èµ„æºåŠ è½½å®Œæˆ');
  } catch (error) {
    console.error('âŒ Spine åŠ è½½å¤±è´¥:', error);
  }
}

/**
 * æ¸²æŸ“ Spine åˆ°èˆå°ï¼ˆå®Œå…¨æ¨¡æ‹Ÿå‚è€ƒé¡¹ç›® main.js line 530-560ï¼‰
 */
function renderToStage(spine: any) {
  if (!app) return;

  const Spine37 = (window as any).PIXI.Spine37;

  // æ¸…ç©ºå¹¶é‡æ–°æ·»åŠ 
  app.stage.removeChildren();

  // åˆ›å»ºå®¹å™¨å¹¶æ·»åŠ  Spineï¼ˆå‚è€ƒ main.js line 527-529ï¼‰
  const container = new PIXI.Container();
  container.addChild(spine);

  // å…³é”®ï¼šåœ¨æ·»åŠ åˆ° container ä¹‹åæ‰è°ƒç”¨ update(0)ï¼ˆå‚è€ƒ main.js line 541ï¼‰
  spine.update(0);

  // ä½¿ç”¨ createGraphics è·å–å‡†ç¡®çš„è¾¹ç•Œï¼ˆå‚è€ƒ main.js line 543-545ï¼‰
  const graphics = new PIXI.Graphics();
  graphics.alpha = 0;

  const skeleton = spine.skeleton;
  const slots = skeleton.slots;

  for (let i = 0, len = slots.length; i < len; i++) {
    const slot = slots[i];
    if (!slot.bone.isActive) continue;

    const attachment = slot.getAttachment();
    if (attachment === null || !(attachment instanceof Spine37.MeshAttachment)) continue;

    const meshAttachment = attachment;
    const vertices = new Float32Array(meshAttachment.worldVerticesLength);
    meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);

    // ç»˜åˆ¶é¡¶ç‚¹è·¯å¾„ä»¥è®¡ç®—è¾¹ç•Œï¼ˆPixiJS v8 æ–¹å¼ï¼‰
    // å°† Float32Array è½¬æ¢ä¸º {x, y} åæ ‡æ•°ç»„
    const points: Array<{ x: number; y: number }> = [];
    for (let j = 0; j < vertices.length; j += 2) {
      points.push({ x: vertices[j], y: vertices[j + 1] });
    }

    graphics.poly(points);
    graphics.fill({ color: 0x000000, alpha: 0 });
  }

  const gpBound = graphics.getLocalBounds();
  console.log('ğŸ“¦ createGraphics bounds:', gpBound);

  // å…³é”®ï¼šè®¾ç½® Spine ä½ç½®ï¼ˆå‚è€ƒ main.js line 546ï¼‰
  spine.position.set(-gpBound.x, -gpBound.y);

  // è®¡ç®—ç¼©æ”¾ï¼ˆå‚è€ƒ main.js line 534-542ï¼‰
  const scale =
    Math.min(
      app.canvas.width / Math.max(skeleton.data.width, gpBound.width),
      app.canvas.height / Math.max(skeleton.data.height, gpBound.height),
    ) * 0.8;

  container.scale.set(scale);

  // å±…ä¸­å®¹å™¨ï¼ˆå‚è€ƒ main.js line 556-558ï¼‰
  const contBounds = container.getLocalBounds();
  container.pivot.set(contBounds.width / 2, contBounds.height / 2);
  container.position.set(app.canvas.width / 2, app.canvas.height / 2);

  // æ·»åŠ å®¹å™¨åˆ°èˆå°
  app.stage.addChild(container);

  console.log('âœ… Spine å·²æ¸²æŸ“åˆ°èˆå°');
  console.log('ğŸ“ Canvas å°ºå¯¸:', { width: app.canvas.width, height: app.canvas.height });
  console.log('ğŸ“ Graphics bounds:', gpBound);
  console.log('ğŸ“ Container ç¼©æ”¾:', scale);
  console.log('ğŸ“ Container ä½ç½®:', container.position);
  console.log('ğŸ“ Spine ä½ç½®:', spine.position);
  console.log('ğŸ“ Spine visible:', spine.visible, 'alpha:', spine.alpha);
  console.log('ğŸ“ Container visible:', container.visible, 'alpha:', container.alpha);
  console.log('ğŸ“ Spine children count:', spine.children ? spine.children.length : 'no children property');
  console.log('ğŸ“ Container children count:', container.children.length);
  console.log('ğŸ“ Container bounds:', container.getBounds());
  console.log('ğŸ“ Stage children:', app.stage.children.length);

  // æ£€æŸ¥ SpinePipe å’Œæ¸²æŸ“æ•°æ®
  const spinePipe = (app.renderer as any).renderPipes?.spine;
  if (spinePipe) {
    console.log('ğŸ“¦ SpinePipe å­˜åœ¨');
    console.log('ğŸ“¦ Spine.uid:', spine.uid);
    console.log('ğŸ“¦ Spine.renderPipeId:', spine.renderPipeId);
    console.log('ğŸ“¦ Spine.batched:', spine.batched);

    // ä¸æ‰‹åŠ¨è°ƒç”¨ addRenderableï¼Œè®© PixiJS çš„æ¸²æŸ“ç®¡çº¿è‡ªåŠ¨å¤„ç†
    console.log('ğŸ“¦ è®© PixiJS è‡ªåŠ¨å¤„ç†æ¸²æŸ“...');

    // å¼ºåˆ¶è§¦å‘ä¸€æ¬¡å®Œæ•´çš„æ¸²æŸ“å¾ªç¯
    app.renderer.render(app.stage);

    // æ£€æŸ¥æ¸²æŸ“åçš„ GPU æ•°æ®
    const gpuData = spinePipe.gpuSpineData?.[spine.uid];
    console.log('ğŸ“¦ æ¸²æŸ“å GPU æ•°æ®:', gpuData);
    if (gpuData) {
      console.log('ğŸ“¦ slotBatches keys:', Object.keys(gpuData.slotBatches || {}));
      console.log('ğŸ“¦ slotBatches count:', Object.keys(gpuData.slotBatches || {}).length);
    }
  } else {
    console.log('âŒ SpinePipe ä¸å­˜åœ¨ï¼');
  }
}
</script>

<style scoped lang="scss">
.spine-player-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

.spine-canvas {
  width: 100%;
  height: 100%;
  display: block;
  position: relative; /* æ”¹ä¸º relative */
}
</style>
