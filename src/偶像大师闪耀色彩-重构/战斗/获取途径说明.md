# 技能卡获取途径系统

## 📚 概述

技能卡的获取是一个**渐进式培育系统**，而不是一开始就随机分配。玩家在培育过程中通过各种途径逐步积累技能卡，构建自己的卡组。

---

## 🎯 核心机制

### 1. P卡专属技能卡

每张P卡（Produce Card）自带**1张专属技能卡**：

- 在选择P卡开始培育时自动获得
- 通常为SSR稀有度
- 效果与P卡主题相关
- 是卡组的核心卡牌之一

```typescript
import { getProduceCardExclusiveSkill } from '../战斗';

// 获取P卡的专属技能卡
const exclusiveSkill = getProduceCardExclusiveSkill('mano_ssr_001');
console.log(exclusiveSkill?.name); // 例如：樱木真乃的专属技能
```

### 2. 回忆卡（S卡）技能卡

每张回忆卡（Support Card）提供**4张技能卡**：

#### 初期型回忆卡

- 培育开始时就获得全部4张技能卡
- 适合需要早期成型的培育计划

#### 期中后型回忆卡

- 培育初期获得2张技能卡
- 期中比赛后解锁另外2张技能卡
- 后期卡通常效果更强

```typescript
import { getSupportCardSkills } from '../战斗';

// 获取回忆卡在初期提供的技能卡
const earlySkills = getSupportCardSkills('support_001', '初期');

// 获取回忆卡在期中后提供的技能卡
const lateSkills = getSupportCardSkills('support_001', '期中后');
```

### 3. 培育过程获取

在培育过程中，可以通过以下途径获取技能卡或P饮料：

| 途径         | 获取内容     | 获取时机     | 备注                     |
| ------------ | ------------ | ------------ | ------------------------ |
| **训练完成** | 技能卡/P饮料 | 每次训练后   | 根据评价等级决定奖励质量 |
| **授课**     | 技能卡       | 授课活动时   | 固定获得1张技能卡        |
| **活动补给** | 技能卡/P饮料 | 活动补给时   | 随机获得                 |
| **自由活动** | P饮料        | 自由活动时   | 低概率获得               |
| **交谈**     | P饮料        | 与角色交谈时 | 低概率获得               |
| **期中比赛** | 技能卡+P饮料 | 期中比赛后   | 根据比赛成绩获得         |
| **期末比赛** | 技能卡+P饮料 | 期末比赛后   | 根据比赛成绩获得         |

---

## 🚀 使用方法

### 1. 构建初始卡组

```typescript
import { buildInitialDeck, getFullDeck } from '../战斗';

// 构建初始卡组
const deckSource = buildInitialDeck(
  'mano_ssr_001',  // P卡ID
  ['support_001', 'support_002', 'support_003'],  // 回忆卡ID列表
  '感性',  // 培育计划
);

console.log('P卡专属:', deckSource.produceCardExclusive);
console.log('回忆卡提供（初期）:', deckSource.supportCardsEarly);
console.log('基础卡牌:', deckSource.acquiredDuringProduce);

// 获取完整卡组
const fullDeck = getFullDeck(deckSource);
console.log(`当前卡组共有 ${fullDeck.length} 张卡`);
```

### 2. 处理培育事件奖励

```typescript
import { getProduceEventReward } from '../战斗';

// 训练完成后获取奖励
const trainingResult = getProduceEventReward(
  '训练_Vocal',  // 事件类型
  '感性',        // 培育计划
  'Perfect',     // 评价等级
);

console.log('获得的技能卡:', trainingResult.acquiredSkillCardIds);
console.log('获得的P饮料:', trainingResult.acquiredPDrinkIds);

// 将获得的技能卡添加到卡组
trainingResult.acquiredSkillCardIds?.forEach(skillCardId => {
  addAcquiredSkillCard(deckSource, skillCardId);
});
```

### 3. 期中后解锁回忆卡技能

```typescript
import { unlockMidtermSupportCardSkills } from '../战斗';

// 期中比赛后，解锁期中后型回忆卡的技能
const updatedDeck = unlockMidtermSupportCardSkills(
  deckSource,
  ['support_001', 'support_002', 'support_003'],
);

console.log('新解锁的技能卡:', updatedDeck.supportCardsLate);
```

---

## 📊 培育阶段与奖励

### 奖励稀有度随阶段提升

| 培育阶段   | 可能获得的稀有度 | 说明              |
| ---------- | ---------------- | ----------------- |
| **初期**   | N, R             | 基础卡为主        |
| **中期**   | R, SR            | 开始出现SR卡      |
| **期中后** | SR, SSR          | 高稀有度卡增多    |
| **后期**   | SR, SSR          | 主要为高稀有度卡  |
| **期末**   | SSR              | 期末比赛奖励为SSR |

```typescript
import { getRecommendedRewardPool } from '../战斗';

// 获取当前阶段推荐的奖励池
const { skillCards, pDrinks } = getRecommendedRewardPool('理性', '期中后');

console.log('可能获得的技能卡:', skillCards.map(c => c.name));
console.log('可能获得的P饮料:', pDrinks.map(d => d.nameCN));
```

---

## 🎮 实战示例

### 完整的培育流程示例

```typescript
import {
  buildInitialDeck,
  getProduceEventReward,
  unlockMidtermSupportCardSkills,
  addAcquiredSkillCard,
  getFullDeck,
  type ProducePlan,
} from '../战斗';

// 1. 初始化培育
const plan: ProducePlan = '理性';
const produceCardId = 'hiori_ssr_001';
const supportCardIds = ['support_logic_001', 'support_logic_002', 'support_early_001'];

let deckSource = buildInitialDeck(produceCardId, supportCardIds, plan);
console.log(`初始卡组: ${getFullDeck(deckSource).length} 张卡`);

// 2. 培育过程
const events = [
  { type: '训练_Vocal', grade: 'Perfect' },
  { type: '授课', grade: 'Great' },
  { type: '训练_Dance', grade: 'Great' },
  { type: '活动补给', grade: 'Normal' },
];

events.forEach((event, index) => {
  console.log(`\n回合 ${index + 1}: ${event.type}`);

  const result = getProduceEventReward(event.type as any, plan, event.grade as any);

  if (result.acquiredSkillCardIds && result.acquiredSkillCardIds.length > 0) {
    console.log(`获得技能卡: ${result.acquiredSkillCardIds.length} 张`);
    result.acquiredSkillCardIds.forEach(id => {
      deckSource = addAcquiredSkillCard(deckSource, id);
    });
  }

  if (result.acquiredPDrinkIds && result.acquiredPDrinkIds.length > 0) {
    console.log(`获得P饮料: ${result.acquiredPDrinkIds.length} 个`);
  }

  console.log(`当前卡组: ${getFullDeck(deckSource).length} 张卡`);
});

// 3. 期中比赛
console.log('\n=== 期中比赛 ===');
const midtermResult = getProduceEventReward('期中比赛', plan, 'Perfect');
console.log(`获得技能卡: ${midtermResult.acquiredSkillCardIds?.length || 0} 张`);
console.log(`获得P饮料: ${midtermResult.acquiredPDrinkIds?.length || 0} 个`);

// 4. 解锁期中后型回忆卡的技能
deckSource = unlockMidtermSupportCardSkills(deckSource, supportCardIds);
console.log('期中后解锁的技能卡:', deckSource.supportCardsLate);

console.log(`\n最终卡组: ${getFullDeck(deckSource).length} 张卡`);
```

---

## 🔧 高级功能

### 卡组来源追踪

`DeckBuildSource` 清晰地记录了每张卡的来源：

```typescript
interface DeckBuildSource {
  produceCardExclusive: string[];    // P卡专属
  supportCardsEarly: string[];       // 回忆卡（初期）
  supportCardsLate: string[];        // 回忆卡（期中后）
  acquiredDuringProduce: string[];   // 培育过程获得
}
```

这样可以：

- 追踪卡牌获取历史
- 分析卡组构成
- 实现"查看卡牌来源"功能

### 自定义奖励逻辑

可以扩展 `getProduceEventReward` 函数来实现自定义奖励：

```typescript
function getCustomReward(eventType: ProduceEventType, difficulty: number) {
  // 根据难度调整奖励
  const baseReward = getProduceEventReward(eventType, '感性', 'Great');

  if (difficulty > 5) {
    // 高难度额外奖励
    baseReward.acquiredSkillCardIds?.push('bonus_card_id');
  }

  return baseReward;
}
```

---

## 💡 设计要点

### 为什么不是随机分配？

1. **符合培育玩法**：玩家通过自己的选择和努力逐步构建卡组
2. **增加策略性**：需要权衡回忆卡类型（初期型 vs 期中后型）
3. **提供成长感**：从弱小到强大的明确进度
4. **避免运气成分过大**：不是一开始就抽卡决定强弱

### 关键函数说明

虽然存在 `getRandomSkillCards()` 和 `getRecommendedSkillCards()` 函数，但它们的用途是：

- **不是**用于初始卡组分配
- **而是**用于培育事件的奖励池选择
- **目的**：从符合条件的卡池中选择合适的奖励

---

**最后更新**: 2025-11-03
**版本**: v1.0.0
